/* This code is modified from the s_sh.c code provided by Marc Thomas
 *
 * Just the command line tokenizing portion of the code has been extracted
 * into this file. This code expects a string on STDIN that needs to be
 * tokenized into a command line argument for passing to an exec call.
 *
 * Here is Dr. Thomas's documentation on the tokenizing aspect of s_sh.c:
 *
 *     i.   It will parse a command line into tokens assuming
 *          that they are separated by whitespace (i.e. spaces,
 *          tabs, or a combination of these). A token is allowed
 *          to contain a space if it is quoted (e.g. "hi there").
 *
 *   call getcmd()
 *       which reads from descriptor 0 into
 *
 *           raw_cmdline[last_cmd][] = "ls -C *.h tmpfile\0"
 *           cmdbuf[]    = "ls -C *.h tmpfile\0"
 *
 *       and then calls
 *       parse_cmdbuf()
 *           which parses line and sets
 * 
 *           raw_cmdline[last_cmd][] = "ls -C *.h tmpfile\0"
 *           cmdbuf[]    = "ls\0-C\0*.h\0tmpfile\0"
 *           cmd[0] --------^   ^   ^    ^
 *           cmd[1] ------------^   ^    ^
 *           cmd[2] ----------------^    ^
 *           cmd[3] ---------------------^
 *           cmd[4] = NULL
 *
 *   report bad command line grammar and/or feature not yet
 *      supported and continue
 *
 *   check for the "exit" command, if found, exit
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <string.h>
#include <errno.h>

/* Set limits on command line and argument lengths */
#define MAX_LINEL   1024
#define MAX_ARGS      64
#define MAX_ARGLEN    64
#define ERROR_MESSAGE 80

int getcmd();
int parse_cmdbuf(char cline[], char *cargv[]);

/* Globals to support the parsing */

char  raw_cmdline[MAX_LINEL];    /* raw command line */
char  cmdbuf[MAX_LINEL];  /* buffer for command line that user will
                   type. this is filled by getcmd() and modified in
                   the process of parsing. */
char  *cmd[MAX_ARGS]; /* array for pointers to tokens which are
                   command line arguments (note that a pointer
                   to a token is the same as a pointer to char).
                   these pointers will actually point to
                   sub-strings in cmdbuf[]. */
char  syntax_error[ERROR_MESSAGE];  /* utility routines will return
                   negative values and leave message here on
                   syntax and grammar errors */


int main(int argc, char *argv[], char *envp[])
{
    int i, count;

    while(1)      /* repeat forever */
    {
        fflush(stdout);
        printf("\r\ns_sh> "); /* put out prompt */
        fflush(stdout);

        count = getcmd(); /* call getcmd() to fill the array of string 
                             pointers cmd[]. note that cmdbuf[] contains 
                             the objects of the pointers in cmd[]. */
       
        if (count < 0) /* Error in parsing input */
        {
            printf("\r\n  error: %s\r\n", syntax_error);
            continue; /* with while(1) */
        }
        if (raw_cmdline[0] == '\0') /* user probably just hit [CR] */
        {
            continue; /* with while(1) */
        }

        if ( (count < 1) || (cmd[0] == NULL) ) /* No command given */
        {
            continue; /* with while(1) */
        }

        if (strcmp(cmd[0], "exit") == 0)
        {
            printf("\r\nExiting program. \r\n");
            fflush(stdout);
            break;
        }

        printf("Parsed command line %s into:\n", raw_cmdline);
        fflush(stdout);
        for(i = 0; i < count; i++)
        {
            printf("cmd[%d] ==> %s\n", i, cmd[i]);
            fflush(stdout);
        }

        /* Note from Melissa:
         *
         * At this point, cmd is in the correct format to pass to execve.
         * You would add the code here to fork() a child process, then 
         * call execve(cmd[0], cmd, envp) within the child process. 
         *
         * The execve() call will error if cmd[0] is a relative pathname 
         * instead of an absolute pathname. To find the absolute path for 
         * a command, use the "which" command:
         *
         * $ which ls
         * /bin/ls
         *
         * Meanwhile, the parent process should call wait() to wait for the
         * child process to finish, then go on to the next iteration of the
         * loop. The parent should NOT exit after waiting and harvesting the
         * child's exit code in this lab.
         */
    }
    return 0;
}

/* --------------------------------------------------------------------- */

int getcmd(void)
{
  /* this procedure, with the help of parse_cmdbuf(), functions
     as a CRUDE command line parser. Spaces and tabs are delimeters
     between tokens. A token can include a space if you quote it, e.g.
     "hello there" is one token.  The following GLOBAL variables are 
     changed after this call:
   
       raw_cmdline[] contains a copy of the raw command line
       cmdbuf[]      contains the processed command line
                     with '\0' after each token
       cmd[]         is an array of pointers to each
                     argument in cmdbuf[] terminated by a 
                     NULL pointer

     Note the following LIMITATIONS:
   
       If the user types a line longer that MAX_LINEL the rest 
       will be thrown away.  

       If a user types a token whose length exceeds MAX_ARGLEN 
       the token will be broken into two (or more) tokens. 

       There must be AT LEAST ONE delimeter between tokens,
       even when using quotes. 
    */

    int i, j, cnum, bytesread, byteswritten;
    char  bytebuf[16];


    /* use byte-by-byte low-level input which is the SAFEST thing to do 
       and check that we don't overflow MAX_LINEL */
    i = 0;
    cmdbuf[i] = '\0';

rd_loop:
    bytesread = read(0, bytebuf, 1);
    /* Loop will exit if there is no byte read, the current character is
       either '\n' or '\r' (enter key), or the buffer is full */
    while ( (bytesread == 1)  &&  (bytebuf[0] != '\r')  &&
            (bytebuf[0] != '\n') && (i < (MAX_LINEL - 1)) )
    {
        if (bytebuf[0] == 000)
        {
            ;     /* ignore NUL */
        }
        else if ( (bytebuf[0] == 010)  || (bytebuf[0] == 0177) ) 
        {   /* Backspace or Delete key */
            if (i > 0)
            {
                i--;
                cmdbuf[i] = '\0';  /* Clear previous character */
            }
            bytebuf[0] = 010;
            bytebuf[1] = ' ';
            bytebuf[2] = 010;
            byteswritten = write(1, bytebuf, 3);
        }
        else    /* accumulate in cmdbuf[] */
        {
            cmdbuf[i] = bytebuf[0]; /* ECHO if we are NOT 
                               talking to a terminal console.  If we are 
                               talking to a terminal console (in cooked 
                               mode) the line will not be passed to us
                               until the user hits [Enter] */
            i++;
            cmdbuf[i] = '\0';
            byteswritten = write(1, bytebuf, 1);
        }
        bytesread = read(0, bytebuf, 1);
    }  /* end of while */

    if ( (bytesread < 0) && (errno == EINTR) )
        goto rd_loop; /* broke out of read() on SIGCLD */
    if (bytesread == 0)
        exit(0);  /* BAD READ. Shouldn't happen with keyboard. */

    cmdbuf[i] = '\0';
    bytebuf[0] = '\r';
    bytebuf[1] = '\n';
    byteswritten = write(1, bytebuf, 2);

    strcpy(raw_cmdline, cmdbuf);  /* make copy in raw_cmdline since 
                                     parse_cmdbuf() will modify cmdbuf[] */

    /* call parse_cmdbuf() - if there was bad grammar j will be negative and 
      there will be an error message in syntax_error[] */
    j = parse_cmdbuf(cmdbuf, cmd);

    return(j);    /* return number of arguments */
}  /* end of getcmd */

/* --------------------------------------------------------------------- */

int parse_cmdbuf(char cline[], char *cargv[])
{
    /* this procedure takes a raw command line in cline[] and
       sets the array cargv[] of pointers is to point to each of the 
       arguments starting with cargv[0], modifying cline[] in the process
       (so the caller should save a copy of the RAW command line).

       The last pointer is set to NULL (this is necessary in order to use 
       exec/spawn() and is one feature which is different from the 
       invocation of main()). 

       If the user types a line longer that MAX_LINEL the rest 
       will be thrown away. If a user types a token whose length exceeds 
       MAX_ARGLEN the token will be broken into two (or more) tokens.

       The number of command line arguments (essentially argc) is returned. 
       for example if cline[] contains:

       $$ <space>/bin/ps  <tab> -ef<cr>

       then  cargv[0] --> "/bin/ps"  
             cargv[1] --> "-ef"     
             cargv[2] --> NULL     
    */

    int i, j, done, inquote, start_i, ret;

    inquote = 0;
    done = 0;
    i = 0;
    j = 0;
    while( (cline[i] != '\0')  &&  (i < (MAX_LINEL - MAX_ARGLEN)) )
    {
        for( ; (cline[i] == ' ') ||
               (cline[i] == '\t') ; i++);  /* skip tab, space */

        cargv[j] = &cline[i]; /* set ptr to beginning of token or '\0' */
        start_i = i;
        if (cline[i] == '\0') break;    /* at eol */
        /* ASCII table has printable characters between 32 and 127 */
        for( ; ( ((inquote == 1) && (cline[i] == 32))
                || (cline[i] > 32) )  && (cline[i] < 127) &&
                   ((i - start_i) < (MAX_ARGLEN - 1)) ; i++)
        {
            /* check start of quote */
            if ( (inquote == 0) && (cline[i] == '"') )
            {
                inquote = 1;
                cargv[j]++;
            }
            /* check end of quote   */
            else if ( (inquote == 1) && (cline[i] == '"') )
            {
                inquote = 0;
                cline[i] = '\0';  /* terminate */
            }
        }  /* end of for().. scan over token string */

        if (cline[i] == '\0')
            done = 1;   /* at EOL */
        else
            cline[i] = '\0';/* terminate token ,i.e. replace
                                whitespace delimeter by '\0' */
        i++;

        if (j < (MAX_ARGS - 1) )
            j++;     /* ready for next token */
        else
            done = 1; /* cargv[] array is full */

        if (done)
            break;    /* array full or at EOL */
    }

    cargv[j] = (char *)NULL;  /* last entry in cmd[] is NULL ptr */

    /* check to see that quotes were closed */
    if (inquote == 1)
    {
        sprintf(syntax_error, "parse_cmd: quote never closed");
        return(-1);
    }

    return(j);    /* return number of arguments */
}  /* end of parse_cmdbuf */

